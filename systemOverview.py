
# collects content similar to M_SYSTEM_OVERVIEW (which is re-implemented in C++)
#
from __future__ import print_function
from __future__ import absolute_import
import sys
import time
import types
import traceback
import NameServerPy
import ServiceClientPy
import ConfigMgrPy
import six
from six.moves import range

class Status:
    Unknown=''
    Ok='OK'
    Warning='WARNING'
    Error='ERROR'


def finalize(result):
    # convert columns to text,
    section=''
    for row in result:
        while len(row)<4: row.append('')
        for i in range(len(row)):
            if not isinstance(row[i], six.string_types): row[i]=str(row[i])
    return result

def collect(cursor=None):
    ns=NameServerPy.TNSClient()
    ns.disableNSLibraryLoad()
    result=[]
    try:
        #
        # collect informations
        #
        q=NameServerPy.TNode('/host/*+/nameserver/*/info')
        q.add('build_version','*')
        q.add('build_branch','*')
        q.add('cpu_cores','*')
        q.add('cpu_threads','*')
        q.add('hw_manufacturer','*')
        q.add('hw_model','*')
        q.add('os_name','*')
        nsinfo=NameServerPy.TNode()
        ns.queryTree(q,nsinfo)

        # same starttime in topology tree and in rs.simplestat()
        q=NameServerPy.TNode('/host/*/*/*')
        q.add('active','yes')
        q.add('start_time','*')
        svinfo=NameServerPy.TNode()
        ns.queryTree(q,svinfo)

        services=ns.getServersDict(NameServerPy.AllServers, NameServerPy.ActiveNo)
        for service in services:
            if service['type']==NameServerPy.NameServer and service['active']==NameServerPy.ActiveYes:
                try:
                    rs=ServiceClientPy.RemoteService('%s:%d'%(service['host'],service['port']))
                    rs.setTimeout(10000)
                    service['stat']=rs.simplestat()
                    # (processCpu,totalCpu,processMem,totalMem,availableMem,physicalMem,
                    #  req_sec,resp_time,finished_req1,finished_req2,active_req,pending_req,
                    #  activeThr,thrCount,openFiles,startTime)
                except:
                    traceback.print_exc()
                    service['stat']=None
            else:
                    service['stat']=None

        #
        # system
        #
        os_names={}
        hosts=[]
        for n1 in nsinfo.getNodes():
            hosts.append(n1.getName())
            os_names[n1.getNode('os_name').getValue()]=True
        os_names=sorted(os_names.keys())
        hosts=sorted(hosts)
        if len(hosts)>1: distributed='Yes (%d hosts)'%len(hosts)
        else:            distributed='No'
        #if len(hosts)>4: hosts='%s,%s,...,%s,%s'%(hosts[0],hosts[1],hosts[-2],hosts[-1])
        #else:            hosts=','.join(hosts)

        result.append(['System','Instance ID'    ,'', ConfigMgrPy.sapgparam('SAPSYSTEMNAME')])
        result.append(['System','Instance Number','', ConfigMgrPy.sapgparam('SAPSYSTEM')])
        result.append(['System','Distributed'    ,'', distributed])
        #result.append(['System','Hosts'          ,'', hosts])
        result.append(['System','Version'        ,'', nsinfo.getNode(0).getNode('build_version').getValue()+' ('+nsinfo.getNode(
0).getNode('build_branch').getValue()+')'])
        result.append(['System','Platform'       ,'', ','.join(os_names)])

        #
        # services
        #
        startmin=None
        startmax=None
        startall=True
        for service in services:
            if service['active']!=NameServerPy.ActiveYes:
                startall=False
        for n1 in svinfo.getNodes():
            for n2 in n1.getNodes():
                for n3 in n2.getNodes():
                    t=n3.getNode('start_time').getValue()
                    if startmin==None or t<startmin: startmin=t
                    if startmax==None or t>startmax: startmax=t
        # alternative implementation (needs more rs.simplestat)
        #for service in services:
        #   if service['stat']:
        #       if startmin==None or service['stat'][15]<startmin: startmin=service['stat'][15]
        #       if startmax==None or service['stat'][15]>startmax: startmax=service['stat'][15]
        #   else:
        #       startall=False

        result.append(['Services','All Started',startall and Status.Ok or Status.Warning,startall and 'Yes' or 'No'])
        result.append(['Services','Min Start Time','',startmin])
        result.append(['Services','Max Start Time','',startmax])
        #result.append(['Services','MinStartTime','',time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(startmin/1000))])
        #result.append(['Services','MaxStartTime','',time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(startmax/1000))])

        #
        # memory
        #
        memphys=0
        memswap=0
        memused=0
        for service in services:
            if service['type']==NameServerPy.NameServer and service['stat']:
                memphys+=service['stat'][5] # values are in KB
                memswap+=service['stat'][4]-service['stat'][5]
                memused+=service['stat'][3]
        status=Status.Ok
        if memused>memphys: status=Status.Warning
        if memused>(2*memphys): status=Status.Error
        result.append(['Memory','Memory',status,'Physical %.2f GB, Swap %.2f GB, Used %.2f'%(memphys/1024.0/1024.0,memswap/1024.
0/1024.0,memused/1024.0/1024.0)])

        #
        # cpu
        #
        cputotl=0
        cpuused=0
        for service in services:
            if service['type']==NameServerPy.NameServer and service['stat']:
                totl=int(nsinfo.getNode(service['host']).getNode('cpu_threads').getValue())
                used=(service['stat'][1])/100.0*totl
                cputotl+=totl
                cpuused+=used
        status=Status.Ok
        if cpuused>(cputotl*.8): status=Status.Warning
        if cpuused>(cputotl*.9): status=Status.Error
        result.append(['CPU','CPU',status,'Available %d, Used %.2f'%(cputotl,cpuused)])

        #
        # disk
        #
        sizes=[['Data',0,0],['Log',0,0],['Trace',0,0]]
        datasize=dataused=logsize=logused=tracesize=traceused=0
        disks=ns.getDiskInfo()
        for i in range(len(disks)):
            disk=disks[i]
            duplicate=False
            for j in range(0,i):
                if disk[1]==disks[j][1] and disk[5]==disks[j][5]: duplicate=True
            if duplicate: continue
            if disk[5] in ('DATA','DATA+LOG'): sizes[0][1]+=disk[6]; sizes[0][2]+=disk[7]
            if disk[5] in ('LOG' ,'DATA+LOG'): sizes[1][1]+=disk[6]; sizes[1][2]+=disk[7]
            if disk[5]=='TRACE':               sizes[2][1]+=disk[6]; sizes[2][2]+=disk[7]
        for size in sizes:
            if size[1]: free=100-size[2]*100.0/size[1]
            else:       free=100
            status=Status.Ok
            if free<10: status=Status.Warning
            if free<2:  status=Status.Error
            result.append(['Disk',size[0],status,'Size %.1f GB, Used %.1f GB, Free %d %%'%(size[1]/1024.0/1024.0/1024.0,  size[2
]/1024.0/1024.0/1024.0, free)])

        #
        # alerts
        #
        if cursor:
            try:
                alerts=[0,0,0,0,0,0]
                cursor.execute("SELECT alert_rating,count(*) FROM _sys_statistics.statistics_current_alerts GROUP BY alert_ratin
g")
                for row in cursor.fetchall():
                    alerts[row[0]]=row[1]
                msg=[]
                if alerts[5]: msg.append('%d Error' %alerts[5])
                if alerts[4]: msg.append('%d High'  %alerts[4]); status=Status.Warning
                if alerts[3]: msg.append('%d Medium'%alerts[3]); status=Status.Warning
                if alerts[2]: msg.append('%d Low'   %alerts[2]); status=Status.Warning
                if alerts[5]:                                    status=Status.Error
                if not msg:   msg.append('No Alerts');           status=Status.Ok
                result.append(['Statistics','Alerts',status,', '.join(msg)])
            except Exception as exc:
                result.append(['Statistics','Alerts',Status.Error  ,'connection to statisticsserver failed: '+str(exc)])
        else:
                result.append(['Statistics','Alerts',Status.Warning,'cannot check statistics w/o SQL connection'])
    #
    #
    except Exception as exc:
        stk = traceback.extract_tb(sys.exc_info()[2])
        result.append(['Error','Internal Error',Status.Error,'%s(%d): %s'%(stk[0][0],stk[0][1],str(exc))])
    return finalize(result)


def print_(infos):
    h=['Section','Name','Status','Value']
    l=[7,4,6,5]
    for info in infos:
        if len(info)!=len(h):
            raise ValueError('invalid info: '+repr(info))
        for i in range(len(info)):
            if len(info[i])>l[i]: l[i]=len(info[i])
    print('|', end=' ')
    for i in range(len(h)):
        print(h[i].ljust(l[i])+' |', end=' ')
    print('\n|', end=' ')
    for i in range(len(h)):
        print('-'*l[i]+' |', end=' ')
    for info in infos:
        print('\n|', end=' ')
        for i in range(len(h)):
            print(info[i].ljust(l[i])+' |', end=' ')
    print()



if __name__ == '__main__':
    from connectionManager import ConnectionManager

    NameServerPy.init()
    try:
        conman = ConnectionManager()
        conn = conman.createConnection()
        cursor = conn.cursor()
    except:
        cursor = None
    infos=collect(cursor=cursor)

    print_(infos)
